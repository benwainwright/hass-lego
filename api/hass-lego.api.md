## API Report File for "hass-lego"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { HassApi } from 'homeassistant-ws';

// @alpha
export class Action<I = void, O = void> extends Block<I, O> {
    constructor(config: {
        readonly name: string;
        callback: ((client: LegoClient, input: I) => O) | ((client: LegoClient, input: I) => Promise<O>);
    });
    // (undocumented)
    readonly config: {
        readonly name: string;
        callback: ((client: LegoClient, input: I) => O) | ((client: LegoClient, input: I) => Promise<O>);
    };
    // (undocumented)
    readonly name: string;
    // Warning: (ae-forgotten-export) The symbol "BlockOutput" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    run(client: LegoClient, events: EventBus, triggerId: string, input: I): Promise<BlockOutput<O>>;
    // (undocumented)
    protected typeString: string;
}

// @alpha
export class Assertion<I = void, O = void> extends Block<I, O> {
    constructor(config: AssertionConfig<I, O>);
    // (undocumented)
    config: AssertionConfig<I, O>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    run(client: LegoClient, events: EventBus, triggerId: string, input: I): Promise<BlockOutput<O>>;
    // (undocumented)
    protected typeString: string;
}

// @alpha
export interface AssertionConfig<I, O> {
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly predicate: (client: LegoClient, input?: I) => boolean | {
        result: boolean;
        output: O;
    } | Promise<{
        result: boolean;
        output: O;
    }>;
}

// @alpha (undocumented)
export class Automation<A extends readonly Block<unknown, unknown>[], I = GetSequenceInput<A>, O = GetSequenceOutput<A>> extends Block<I, O> {
    constructor(config: {
        name: string;
        actions: A & ValidInputOutputSequence<I, O, A>;
        trigger?: Trigger<I>;
        mode?: ExecutionMode;
    });
    // (undocumented)
    attachTrigger(client: LegoClient, bus: EventBus): void;
    // (undocumented)
    config: {
        name: string;
        actions: A & ValidInputOutputSequence<I, O, A>;
        trigger?: Trigger<I>;
        mode?: ExecutionMode;
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    protected run(client: LegoClient, events: EventBus, triggerId: string, input?: I): Promise<BlockOutput<O>>;
    // (undocumented)
    protected typeString: string;
}

// @alpha (undocumented)
export interface AutomationRegistered<I = unknown, O = unknown> {
    // (undocumented)
    block: Block<I, O>;
    // (undocumented)
    name: string;
    // (undocumented)
    status: "registered";
    // (undocumented)
    type: "automation";
}

// @alpha (undocumented)
export abstract class Block<I = void, O = void> {
    // (undocumented)
    execute(client: LegoClient, events: EventBus, input: I, triggerId: string, parent?: Block<unknown, unknown>, triggeredBy?: Trigger<unknown>): Promise<BlockOutput<O> & {
        success: boolean;
    }>;
    inputType: I | undefined;
    // (undocumented)
    abstract readonly name: string;
    outputType: O | undefined;
    // (undocumented)
    protected abstract run(client: LegoClient, events: EventBus, triggerId: string, input: I): Promise<BlockOutput<O>> | BlockOutput<O>;
    // (undocumented)
    protected abstract readonly typeString: string;
}

// @alpha (undocumented)
export class EventBus {
    // (undocumented)
    emit<I, O>(event: HassLegoEvent<I, O>): void;
    // (undocumented)
    subscribe<I, O>(callback: (event: HassLegoEvent<I, O> & {
        id: string;
    }) => void): void;
}

// @alpha (undocumented)
export enum ExecutionMode {
    Parallel = "Parallel",
    Queue = "Queue",
    Restart = "Restart"
}

// @alpha (undocumented)
export interface GeneralFailure {
    // (undocumented)
    error: Error;
    // (undocumented)
    message: string;
    // (undocumented)
    status: "error";
    // (undocumented)
    type: "generalFailure";
}

// @alpha
export type GetSequenceInput<T extends ReadonlyArray<unknown>> = T extends readonly [infer First, ...unknown[]] ? First extends Block<unknown, unknown> ? InputType<First> : never : never;

// @alpha
export type GetSequenceOutput<T extends ReadonlyArray<unknown>> = T extends readonly [...unknown[], infer Last] ? Last extends Block<unknown, unknown> ? OutputType<Last> : never : never;

// @alpha (undocumented)
export type HassContext = {
    id: string;
    user_id: string | null;
    parent_id: string | null;
};

// @alpha (undocumented)
export type HassEntity = HassEntityBase & {
    attributes: {
        [key: string]: any;
    };
};

// @alpha (undocumented)
export type HassEntityAttributeBase = {
    friendly_name?: string;
    unit_of_measurement?: string;
    icon?: string;
    entity_picture?: string;
    supported_features?: number;
    hidden?: boolean;
    assumed_state?: boolean;
    device_class?: string;
    state_class?: string;
    restored?: boolean;
};

// @alpha (undocumented)
export type HassEntityBase = {
    entity_id: string;
    state: string;
    last_changed: string;
    last_updated: string;
    attributes: HassEntityAttributeBase;
    context: HassContext;
};

// @alpha (undocumented)
export type HassEvent = HassEventBase & {
    event_type: string;
    data: {
        [key: string]: any;
    };
};

// @alpha (undocumented)
export type HassEventBase = {
    origin: string;
    time_fired: string;
    context: HassContext;
};

// Warning: (ae-forgotten-export) The symbol "TriggerFailed" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TriggerFinished" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TriggerStarted" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockFailed" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockFinished" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockStarted" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SequenceAborted" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
export type HassLegoEvent<I = unknown, O = unknown> = AutomationRegistered<I, O> | GeneralFailure | StateChanged | TriggerFailed | TriggerFinished | TriggerStarted | BlockFailed<I, O> | BlockFinished<I, O> | BlockStarted<I, O> | SequenceAborted<I, O>;

// @alpha (undocumented)
export type HassStateChangedEvent = HassEventBase & {
    event_type: "state_changed";
    data: {
        entity_id: string;
        new_state: HassEntity | null;
        old_state: HassEntity | null;
    };
};

// @alpha
export type InputType<T extends Block<unknown, unknown>> = Exclude<T["inputType"], undefined>;

// @alpha (undocumented)
export class LegoClient {
    constructor(client: HassApi, bus: EventBus);
    // (undocumented)
    callService<T>(domain: string, service: string, extraArgs?: Record<string, unknown>, options?: {
        returnResponse?: boolean;
    }): Promise<T>;
    // (undocumented)
    getEntity(id: string): HassEntity;
    // (undocumented)
    getState(id: string): string;
    // (undocumented)
    init(): Promise<void>;
    // (undocumented)
    onStateChanged(id: string, callback: (event: HassStateChangedEvent) => void): void;
    // (undocumented)
    registerAutomation<A extends ReadonlyArray<Block<any, any>>, I = any, O = any>(automation: Automation<A, I, O>): void;
    // (undocumented)
    states: Map<string, HassEntity> | undefined;
}

// @alpha
export type OutputType<T extends Block<unknown, unknown>> = Exclude<T["outputType"], undefined> extends Promise<infer T> ? T : Exclude<T["outputType"], undefined>;

// @alpha (undocumented)
export const renderSimpleLog: (bus: EventBus, staticLog: boolean) => void;

// @alpha (undocumented)
export interface StateChanged {
    // (undocumented)
    entity: string;
    // (undocumented)
    hassEvent: HassStateChangedEvent;
    // (undocumented)
    type: "hass-state-changed";
}

// @alpha (undocumented)
export class Trigger<O> {
    constructor(name: string, id: string, predicate?: ((event: StateChanged, client: LegoClient) => boolean | {
        result: boolean;
        output: O;
    } | Promise<{
        result: boolean;
        output: O;
    }>) | undefined);
    // (undocumented)
    doTrigger(event: StateChanged, client: LegoClient, events: EventBus, triggerId: string): Promise<{
        result: boolean;
        output: O;
    }>;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly name: string;
}

// @alpha (undocumented)
export type ValidInputOutputSequence<I, O, A extends readonly Block<unknown, unknown>[]> = A extends readonly [infer Only extends Block<unknown, unknown>] ? InputType<Only> extends I ? OutputType<Only> extends O ? readonly [Only] : never : never : A extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? InputType<First> extends I ? readonly [First, ...ValidInputOutputSequence<OutputType<First>, O, Rest>] : never : never;

// (No @packageDocumentation comment for this package)

```
