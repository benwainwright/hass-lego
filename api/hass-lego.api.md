## API Report File for "hass-lego"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { CallServiceCommand } from 'homeassistant-typescript';
import { CallServiceResponse } from 'homeassistant-typescript';
import { Event as Event_2 } from 'homeassistant-typescript';
import { IClient } from 'homeassistant-typescript';
import { IncomingMessage } from 'http';
import { Server } from 'http';
import { ServerResponse } from 'http';

// @alpha
export class Action<I = void, O = void> extends Block<I, O> {
    constructor(config: {
        readonly name: string;
        readonly id?: string;
        callback: ((client: LegoClient, input: I) => O) | ((client: LegoClient, input: I) => Promise<O>);
    });
    // (undocumented)
    readonly config: {
        readonly name: string;
        readonly id?: string;
        callback: ((client: LegoClient, input: I) => O) | ((client: LegoClient, input: I) => Promise<O>);
    };
    // (undocumented)
    readonly name: string;
    // Warning: (ae-forgotten-export) The symbol "BlockOutput" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    run(client: LegoClient, input: I): Promise<BlockOutput<O>>;
    // (undocumented)
    readonly typeString: string;
}

// @alpha
export class Assertion<I = void, O = void> extends Block<I, O> {
    constructor(config: AssertionConfig<I, O>);
    // (undocumented)
    config: AssertionConfig<I, O>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    run(client: LegoClient, input: I): Promise<BlockOutput<O>>;
    // (undocumented)
    typeString: string;
}

// @alpha
export interface AssertionConfig<I, O> {
    // (undocumented)
    id?: string;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly predicate: (client: LegoClient, input?: I) => Promise<boolean> | boolean | {
        result: boolean;
        output: O;
    } | Promise<{
        result: boolean;
        output: O;
    }>;
}

// @alpha (undocumented)
export class Automation<const A extends readonly any[], I = GetSequenceInput<A>, O = GetSequenceOutput<A>> extends Block<I, O> {
    constructor(config: {
        name: string;
        id?: string;
        actions: BlockRetainType<A> & A & ValidInputOutputSequence<I, O, A>;
        trigger?: Trigger<I> | Trigger<I>[];
        mode?: ExecutionMode;
    });
    // (undocumented)
    attachTrigger(client: LegoClient, bus: EventBus): Promise<void>;
    // (undocumented)
    config: {
        name: string;
        id?: string;
        actions: BlockRetainType<A> & A & ValidInputOutputSequence<I, O, A>;
        trigger?: Trigger<I> | Trigger<I>[];
        mode?: ExecutionMode;
    };
    // (undocumented)
    readonly name: string;
    // (undocumented)
    run(client: LegoClient, input?: I, events?: EventBus, triggerId?: string): Promise<BlockOutput<O>>;
    // (undocumented)
    typeString: string;
    // (undocumented)
    validate(client: LegoClient): Promise<void>;
}

// @alpha (undocumented)
export interface AutomationRegistered {
    // Warning: (ae-forgotten-export) The symbol "SerialisedBlock" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    block: SerialisedBlock;
    // (undocumented)
    name: string;
    // (undocumented)
    status: "registered";
    // (undocumented)
    type: "automation";
}

// @alpha (undocumented)
export abstract class Block<I = void, O = void> {
    constructor(_id: string);
    get id(): string;
    inputType: I | undefined;
    // (undocumented)
    abstract readonly name: string;
    outputType: O | undefined;
    // (undocumented)
    abstract run(client: LegoClient, input: I, events?: EventBus, triggerId?: string): Promise<BlockOutput<O>> | BlockOutput<O>;
    // (undocumented)
    toJson(): {
        type: string;
        id: string;
        name: string;
    };
    // (undocumented)
    abstract readonly typeString: string;
    validate(client: LegoClient): Promise<void>;
}

// @alpha (undocumented)
export const concurrently: <A extends readonly Block<unknown, unknown>[], I = void, O = void>(actions: A) => Block<I, O>;

// @alpha (undocumented)
export interface ContinueOutput<O> {
    // (undocumented)
    continue: true;
    // (undocumented)
    output: O;
    // (undocumented)
    outputType: "block";
}

// @alpha (undocumented)
export interface CorsOptions {
    // (undocumented)
    methods: string[];
    // (undocumented)
    origin: string;
}

// @alpha (undocumented)
export class EntityDoesNotExistError extends HassLegoError {
    constructor(id: string);
}

// @alpha (undocumented)
export class EventBus {
    // (undocumented)
    emit(event: HassLegoEvent): void;
    // (undocumented)
    subscribe(callback: (event: HassLegoEvent & {
        id: string;
        timestamp: string;
    }) => void): void;
}

// @alpha (undocumented)
export class ExecutionAbortedError extends HassLegoError {
    constructor(name: string);
}

// @alpha (undocumented)
export enum ExecutionMode {
    Parallel = "Parallel",
    Queue = "Queue",
    Restart = "Restart"
}

// @alpha (undocumented)
export interface GeneralFailure {
    // (undocumented)
    error: Error;
    // (undocumented)
    message: string;
    // (undocumented)
    status: "error";
    // (undocumented)
    type: "generalFailure";
}

// @alpha
export type GetSequenceInput<T extends ReadonlyArray<unknown>> = T extends readonly [infer First, ...unknown[]] ? First extends Block<unknown, unknown> ? InputType<First> : never : never;

// @alpha
export type GetSequenceOutput<T extends ReadonlyArray<unknown>> = T extends readonly [...unknown[], infer Last] ? Last extends Block<unknown, unknown> ? OutputType<Last> : never : never;

// @alpha (undocumented)
export type HassContext = {
    id: string;
    user_id: string | null;
    parent_id: string | null;
};

// @alpha (undocumented)
export type HassEntity = HassEntityBase & {
    attributes: {
        [key: string]: any;
    };
};

// @alpha (undocumented)
export type HassEntityAttributeBase = {
    friendly_name?: string;
    unit_of_measurement?: string;
    icon?: string;
    entity_picture?: string;
    supported_features?: number;
    hidden?: boolean;
    assumed_state?: boolean;
    device_class?: string;
    state_class?: string;
    restored?: boolean;
};

// @alpha (undocumented)
export type HassEntityBase = {
    entity_id: string;
    state: string;
    last_changed: string;
    last_updated: string;
    attributes: HassEntityAttributeBase;
    context: HassContext;
};

// @alpha (undocumented)
export type HassEvent = HassEventBase & {
    event_type: string;
    data: {
        [key: string]: any;
    };
};

// @alpha (undocumented)
export type HassEventBase = {
    origin: string;
    time_fired: string;
    context: HassContext;
};

// @alpha (undocumented)
export class HassLegoError extends Error {
    constructor(message: string);
}

// Warning: (ae-forgotten-export) The symbol "BlockFailed" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockFinished" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockPending" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "BlockStarted" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SequenceAborted" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
export type HassLegoEvent = AutomationRegistered | GeneralFailure | StateChanged | BlockFailed | BlockFinished | BlockPending | BlockStarted | SequenceAborted;

// @alpha (undocumented)
export type HassStateChangedEvent = HassEventBase & {
    event_type: "state_changed";
    data: {
        entity_id: string;
        new_state: HassEntity | null;
        old_state: HassEntity | null;
    };
};

// Warning: (ae-incompatible-release-tags) The symbol "IfThenElseCondition" is marked as @public, but its signature references "Block" which is marked as @alpha
//
// @public
export class IfThenElseCondition<TO = void, EO = void, PO = void, I = void> extends Block<I, TO | EO> {
    constructor(config: IfThenElseConditionConfig<TO, EO, PO, I>);
    // (undocumented)
    readonly config: IfThenElseConditionConfig<TO, EO, PO, I>;
    // (undocumented)
    name: string;
    // Warning: (ae-incompatible-release-tags) The symbol "run" is marked as @public, but its signature references "LegoClient" which is marked as @alpha
    // Warning: (ae-incompatible-release-tags) The symbol "run" is marked as @public, but its signature references "EventBus" which is marked as @alpha
    //
    // (undocumented)
    run(client: LegoClient, input: I, events?: EventBus, triggerId?: string): Promise<BlockOutput<TO | EO>>;
    // (undocumented)
    typeString: string;
}

// @public (undocumented)
export interface IfThenElseConditionConfig<TO = void, EO = void, PO = void, I = void> {
    // Warning: (ae-incompatible-release-tags) The symbol "assertion" is marked as @public, but its signature references "Assertion" which is marked as @alpha
    readonly assertion: Assertion<I, PO>;
    // Warning: (ae-incompatible-release-tags) The symbol "else" is marked as @public, but its signature references "Block" which is marked as @alpha
    readonly else: Block<PO, EO>;
    readonly id?: string;
    readonly name: string;
    // Warning: (ae-incompatible-release-tags) The symbol "then" is marked as @public, but its signature references "Block" which is marked as @alpha
    readonly then: Block<PO, TO>;
}

// @alpha (undocumented)
export class InitialStatesNotLoadedError extends HassLegoError {
    constructor();
}

// @alpha
export type InputType<T extends Block<unknown, unknown>> = Exclude<T["inputType"], undefined>;

// @alpha (undocumented)
export class LegoClient {
    constructor(client: IClient, bus: EventBus);
    // (undocumented)
    callService(params: {
        domain: string;
        service: string;
        target?: {
            entity_id?: string | string[];
            area_id?: string | string[];
            device_id?: string | string[];
        };
        data?: Record<string, unknown>;
    }): Promise<CallServiceResponse>;
    // (undocumented)
    getEntity(id: string): HassEntity;
    // (undocumented)
    getState(id: string): string;
    // (undocumented)
    getWebsocketServer({ cors }: {
        cors: CorsOptions;
    }): Server<IncomingMessage, ServerResponse>;
    loadStates(): Promise<void>;
    // (undocumented)
    onStateChanged(id: string, callback: (event: Event_2) => void): Promise<void>;
    // (undocumented)
    registerAutomation<A extends ReadonlyArray<any>, I = any, O = any>(automation: Automation<A, I, O>): Promise<void>;
    // (undocumented)
    states: Map<string, HassEntity> | undefined;
}

// @alpha
export type OutputType<T extends Block<unknown, unknown>> = Exclude<T["outputType"], undefined> extends Promise<infer T> ? T : Exclude<T["outputType"], undefined>;

// @alpha (undocumented)
export const renderSimpleLog: (bus: EventBus, staticLog: boolean) => void;

// @alpha (undocumented)
export const sequence: <const A extends readonly any[], I = GetSequenceInput<A>, O = GetSequenceOutput<A>>(actions: BlockRetainType<A> & A & ValidInputOutputSequence<I, O, A>, mode?: ExecutionMode) => Automation<A, I, O>;

// @alpha (undocumented)
export class ServiceCall extends Action {
    constructor(serviceConfig: {
        name: string;
        params: Omit<CallServiceCommand, "id" | "type">;
    });
    // (undocumented)
    toJson(): {
        type: string;
        id: string;
        name: string;
        params: Omit<CallServiceCommand, "id" | "type">;
        response: CallServiceResponse | undefined;
    };
    // (undocumented)
    typeString: string;
}

// @alpha (undocumented)
export interface StateChanged {
    // (undocumented)
    entity: string;
    // (undocumented)
    hassEvent: Event_2;
    // (undocumented)
    type: "hass-state-changed";
}

// @alpha (undocumented)
export interface StopOutput {
    // (undocumented)
    continue: false;
}

// @alpha (undocumented)
export class Trigger<O> {
    constructor(name: string, id: string, predicate?: ((event: StateChanged, client: LegoClient) => boolean | {
        result: boolean;
        output: O;
    } | Promise<{
        result: boolean;
        output: O;
    }>) | undefined);
    // (undocumented)
    doTrigger(event: StateChanged, client: LegoClient, events: EventBus, triggerId: string, parent: Block<unknown, unknown>): Promise<{
        result: boolean;
        output: O;
    }>;
    // (undocumented)
    readonly id: string;
    // (undocumented)
    readonly name: string;
}

// @alpha (undocumented)
export type ValidInputOutputSequence<I, O, A extends readonly Block<unknown, unknown>[]> = A extends readonly [infer Only extends Block<unknown, unknown>] ? InputType<Only> extends I ? OutputType<Only> extends O ? readonly [Only] : never : never : A extends readonly [
infer First extends Block<unknown, unknown>,
...infer Rest extends readonly Block<unknown, unknown>[]
] ? InputType<First> extends I ? readonly [First, ...ValidInputOutputSequence<OutputType<First>, O, Rest>] : never : never;

// @public
export const when: <TO = void, EO = void, PO = void, I = void>(config: {
    assertion: Assertion<I, PO>;
    then: Block<PO, TO>;
    else: Block<PO, EO>;
}) => IfThenElseCondition<TO, EO, PO, I>;

// Warnings were encountered during analysis:
//
// src/building-blocks/automation.ts:36:7 - (ae-forgotten-export) The symbol "BlockRetainType" needs to be exported by the entry point index.d.ts
// src/building-blocks/condition.ts:116:3 - (ae-incompatible-release-tags) The symbol "assertion" is marked as @public, but its signature references "Assertion" which is marked as @alpha
// src/building-blocks/condition.ts:117:3 - (ae-incompatible-release-tags) The symbol "then" is marked as @public, but its signature references "Block" which is marked as @alpha
// src/building-blocks/condition.ts:118:3 - (ae-incompatible-release-tags) The symbol "else" is marked as @public, but its signature references "Block" which is marked as @alpha

// (No @packageDocumentation comment for this package)

```
